SQL database :



Syntax:--

The "SELECT" statement is used to select data from a database.

The data returned is stored in a result table, called the result-set.


SELECT DISTINCT column1, column2, ...  
FROM table_name;

Here, column1, column2, ... are the field names of the table you want to select data from. If you want to select all the fields available in the table, use the following syntax:

SELECT * FROM table_name; 

SELECT CustomerName, City FROM Customers;





The "WHERE" clause is used to filter records.

It is used to extract only those records that fulfill a specified condition.

SELECT column1, column2, ...
FROM table_name
WHERE condition; 

	The following operators can be used in the WHERE clause:

	= 	Equal 	
	> 	Greater than 	
	< 	Less than 	
	>= 	Greater than or equal 	
	<= 	Less than or equal 	
	<> 	Not equal. Note: In some versions of SQL this operator may be written as != 	
	BETWEEN 	Between a certain range 	
	LIKE 	Search for a pattern 	
	IN 	To specify multiple possible values for a column





Logical AND OR NOT 
	The WHERE clause can be combined with AND, OR, and NOT operators.

	The AND and OR operators are used to filter records based on more than one condition:

	    The AND operator displays a record if all the conditions separated by AND are TRUE.
	    The OR operator displays a record if any of the conditions separated by OR is TRUE.

	The NOT operator displays a record if the condition(s) is NOT TRUE.

	SELECT * FROM Customers
	WHERE Country='Germany' AND (City='Berlin' OR City='München'); 


	The following SQL statement selects all fields from "Customers" where country is NOT "Germany" and NOT "USA":
	Example
	Get your own SQL Server
	SELECT * FROM Customers
	WHERE NOT Country='Germany' AND NOT Country='USA'; 





SQL ORDER BY Keyword >>

The ORDER BY keyword is used to sort the result-set in ascending or descending order.
The ORDER BY keyword sorts the records in ascending order by default. To sort the records in descending order, use the DESC keyword.


  "CustomerName" column. This means that it orders by Country, but if some rows have the same Country, it orders them by CustomerName:
Example                              

SELECT * FROM Customers
ORDER BY Country, CustomerName;         //the first is ordered by country and then after that it will be ordered by customerName





The following SQL statement selects all customers from the "Customers" table, sorted ascending by the "Country" and descending by the "CustomerName" column:
Example

SELECT * FROM Customers
ORDER BY Country ASC, CustomerName DESC; 





INSERT INTO

	It is possible to write the INSERT INTO statement in two ways:
	Specify both the column names and the values to be inserted:

	INSERT INTO table_name (column1, column2, column3, ...)
	VALUES (value1, value2, value3, ...); 
if you are adding all the column vlues then u need not to type all the column name .


NULL  values

	A field with a NULL value is a field with no value.

	If a field in a table is optional, it is possible to insert a new record or update a record without adding a value to this field. 	then, the field will be saved with a NULL value.

	It is not possible to test for NULL values with comparison operators, such as =, <, or <>.
	We will have to use the IS NULL and IS NOT NULL operators instead. 

	It is not possible to test for NULL values with comparison operators, such as =, <, or <>.
	We will have to use the IS NULL and IS NOT NULL operators instead.
	
	SELECT column_names
	FROM table_name
	WHERE column_name IS NULL; 




UPDATE (methode should be used with caution ):
	The UPDATE statement is used to modify the existing records in a table.
	
	UPDATE table_name
	SET column1 = value1, column2 = value2, ...
	WHERE condition;							this WHERE condition is must must must

	Note: Be careful when updating records in a table! Notice the WHERE clause in the UPDATE statement. The WHERE clause specifies which record(s) that should be updated. If you omit the WHERE clause, all records in the table will be updated!




DELETE:-

	The DELETE statement is used to delete existing records in a table.

	DELETE FROM table_name WHERE condition;					   where condition is must here

	Note: Be careful when deleting records in a table! Notice the WHERE clause in the DELETE statement. The WHERE clause specifies which 		record(s) should be deleted. If you omit the WHERE clause, all records in the table will be deleted!


	It is possible to delete all rows in a table without deleting the table. This means that the table structure, attributes, and indexes 		will be intact:
	DELETE FROM table_name;


SELECT TOP : ---
	The SELECT TOP clause is used to specify the number of records to return.

	The SELECT TOP clause is useful on large tables with thousands of records. Returning a large number of records can impact performance.

	Note: Not all database systems support the SELECT TOP clause. MySQL supports the LIMIT clause to select a limited number of records, 			while Oracle uses FETCH FIRST n ROWS ONLY and ROWNUM.


		SQL Server / MS Access Syntax:

		SELECT TOP number|percent column_name(s)
		FROM table_name
		WHERE condition;

		MySQL Syntax:

		SELECT column_name(s)
		FROM table_name
		WHERE condition
		LIMIT number;

		Oracle 12 Syntax:

		SELECT column_name(s)
		FROM table_name
		ORDER BY column_name(s)
		FETCH FIRST number ROWS ONLY;

		Older Oracle Syntax:

		SELECT column_name(s)
		FROM table_name
		WHERE ROWNUM <= number;

		Older Oracle Syntax (with ORDER BY):

		SELECT *
		FROM (SELECT column_name(s) FROM table_name ORDER BY column_name(s))
		WHERE ROWNUM <= number; 




MIN  and MAX 
	The MIN() function returns the smallest value of the selected column.

	The MAX() function returns the largest value of the selected column.
	MIN() Syntax
	SELECT MIN(column_name)
	FROM table_name
	WHERE condition; 

COUNT() AVG() sum() 

	 The SQL COUNT(), AVG() and SUM() Functions

	The COUNT() function returns the number of rows that matches a specified criterion.
	COUNT() Syntax
	SELECT COUNT(column_name)
	FROM table_name
	WHERE condition; 


LIKE :

	The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.
	There are two wildcards often used in conjunction with the LIKE operator:

	     The percent sign (%) represents zero, one, or multiple characters
 	    The underscore sign (_) represents one, single character.
	
	SELECT column1, column2, ...
	FROM table_name
	WHERE columnN LIKE pattern; 

WildCards: -


	Wildcard Characters in SQL Server
	Symbol 	Description 	Example
	% 	Represents zero or more characters 	bl% finds bl, black, blue, and blob
	_ 	Represents a single character 	h_t finds hot, hat, and hit
	[] 	Represents any single character within the brackets 	h[oa]t finds hot and hat, but not hit
	^ 	Represents any character not in the brackets 	h[^oa]t finds hit, but not hot and hat
	- 	Represents any single character within the specified range 	c[a-b]t finds cat and cbt



IN properties :

	The IN operator allows you to specify multiple values in a WHERE clause.

	The IN operator is a shorthand for multiple OR conditions.

	SELECT column_name(s)
	FROM table_name
	WHERE column_name IN (value1, value2, ...); 

	SELECT column_name(s)
	FROM table_name
	WHERE column_name IN (SELECT STATEMENT); 



	SELECT * FROM Customers
	WHERE Country NOT IN ('Germany', 'France', 'UK');

	The following SQL statement selects all customers that are from the same countries as the suppliers:
	
	SELECT * FROM Customers
	WHERE Country IN (SELECT Country FROM Suppliers);



BETWEEN

	The BETWEEN operator selects values within a given range. The values can be numbers, text, or dates.

	The BETWEEN operator is inclusive: begin and end values are included. 
	BETWEEN Syntax
	SELECT column_name(s)
	FROM table_name
	WHERE column_name BETWEEN value1 AND value2; 

	To display the products outside the range of the previous example, use NOT BETWEEN:


	SELECT * FROM Products
	WHERE Price BETWEEN 10 AND 20
	AND CategoryID NOT IN (1,2,3);


ALiase :-
	SELECT CustomerID AS ID, CustomerName AS Customer
	FROM Customers;


	ID	Customer
	1  	Alfreds Futterkiste 

	SELECT CustomerName AS Customer, ContactName AS [Contact Person]
	FROM Customers;


		Customer	    Contact Person
	Alfreds Futterkiste  	 	Maria Anders 



JOIN :--  must be studied



	    (INNER) JOIN: Returns records that have matching values in both tables
	    LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table
	    RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table
	    FULL (OUTER) JOIN: Returns all records when there is a match in either left or right table





	SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate      // this is to specify which column"s should be shown on table
	FROM Orders
	INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID;     // this is to specify which column is same in both




SELF JOIN :-

	A self join is a regular join, but the table is joined with itself.

	SELECT column_name(s)
	FROM table1 T1, table1 T2
	WHERE condition;



        SELECT A.CustomerName As CustomerName1, B.CustomerName AS CustomerName2, A.City
	FROM Customers A ,Customers B                          // this line is same as      FROM Customers AS A ,Customers AS B    
	WHERE A.CustomerID <> B.CustomerID
	AND A.City = B.City 
	ORDER BY A.City;





UNION :---
	The UNION operator is used to combine the result-set of two or more SELECT statements.

	    Every SELECT statement within UNION must have the same number of columns
	    The columns must also have similar data types
	    The columns in every SELECT statement must also be in the same order

	UNION Syntax

	SELECT column_name(s) FROM table1
	UNION
	SELECT column_name(s) FROM table2; 

 	Note: If some customers or suppliers have the same city, each city will only be listed once, because UNION selects only distinct values. Use UNION ALL to also select duplicate values!


	SELECT City FROM Customers
	UNION ALL
	SELECT City FROM Suppliers
	ORDER BY City;


	The following SQL statement returns the German cities (duplicate values also) from both the "Customers" and the "Suppliers" table:

	SELECT City, Country FROM Customers
	WHERE Country='Germany'

	UNION ALL

	SELECT City, Country FROM Suppliers
	WHERE Country='Germany'

	ORDER BY City;


GROUP BY :--

	The GROUP BY statement groups rows that have the same values into summary rows, like "find the number of customers in each country".
	The GROUP BY statement is often used with aggregate functions (COUNT(), MAX(), MIN(), SUM(), AVG()) to group the result-set by one or 		more columns.

	SELECT COUNT(CustomerID) as numberOFCustomer, Country   
	FROM Customers
	GROUP BY Country;

		// here first from countries table country is grouped then count will work on summary rows


	SELECT COUNT(CustomerID), Country
	FROM Customers
	GROUP BY Country
	ORDER BY COUNT(CustomerID) DESC;
			// here first customers table is grouped by country and summaries is given to count which will create rows with number of customersfrom that country and only country column >> and then order by work on that table




HAVING :-

	The HAVING clause was added to SQL because the WHERE keyword cannot be used with aggregate functions.

	SELECT column_name(s)
	FROM table_name
	WHERE condition
	GROUP BY column_name(s)
	HAVING condition
	ORDER BY column_name(s); 


	The following SQL statement lists the number of customers in each country. Only include countries with more than 5 customers:


	SELECT COUNT(CustomerID), Country
	FROM Customers
	GROUP BY Country
	HAVING COUNT(CustomerID) > 5;


EXISTS

	The EXISTS operator is used to test for the existence of any record in a subquery.
	The EXISTS operator returns TRUE if the subquery returns one or more records.


	he following SQL statement returns TRUE and lists the suppliers with a product price less than 20:

	SELECT SupplierName
	FROM Suppliers
	WHERE EXISTS (SELECT ProductName FROM Products WHERE Products.SupplierID = Suppliers.supplierID AND Price < 20); 



SQL ANY and ALL operator :-
	The ANY and ALL operators allow you to perform a comparison between a single column value and a range of other values.
	The SQL ANY Operator

	The ANY operator:

	    returns a boolean value as a result
	    returns TRUE if ANY of the subquery values meet the condition

	ANY means that the condition will be true if the operation is true for any of the values in the range.


	SELECT column_name(s)
	FROM table_name
	WHERE column_name operator ANY
	  (SELECT column_name
	  FROM table_name
	  WHERE condition);

	Note: The operator must be a standard comparison operator (=, <>, !=, >, >=, <, or <=).



	The ALL operator:

	    returns a boolean value as a result
	    returns TRUE if ALL of the subquery values meet the condition
	    is used with SELECT, WHERE and HAVING statements

	ALL means that the condition will be true only if the operation is true for all values in the range. 



	SELECT ALL column_name(s)
	FROM table_name
	WHERE condition;

	ALL Syntax With WHERE or HAVING

	SELECT column_name(s)
	FROM table_name
	WHERE column_name operator ALL
	  (SELECT column_name
	  FROM table_name
	  WHERE condition);

	Note: The operator must be a standard comparison operator (=, <>, !=, >, >=, <, or <=).



The following SQL statement lists the ProductName if it finds ANY records in the OrderDetails table has Quantity equal to 10 (this will return TRUE because the Quantity column has some values of 10):

	SELECT ProductName
	FROM Products
	WHERE ProductID = ANY
	  (SELECT ProductID
	  FROM OrderDetails
	  WHERE Quantity = 10); 




SELECT INTO : -- 
	The SELECT INTO statement copies data from one table into a new table.

	Copy all columns into a new table:

	SELECT *
	INTO newtable [IN externaldb]
	FROM oldtable
	WHERE condition;

	Copy only some columns into a new table:

	SELECT column1, column2, column3, ...
	INTO newtable [IN externaldb]
	FROM oldtable
	WHERE condition;

	The new table will be created with the column-names and types as defined in the old table. You can create new column names using the 		AS clause.


	The following SQL statement creates a backup copy of Customers:-

	SELECT * INTO CustomersBackup2017
	FROM Customers;

	The following SQL statement uses the IN clause to copy the table into a new table in another database:-

	SELECT * INTO CustomersBackup2017 IN 'Backup.mdb'
	FROM Customers;

	The following SQL statement copies only a few columns into a new table:-

	SELECT CustomerName, ContactName INTO CustomersBackup2017
	FROM Customers; 

		Tip: SELECT INTO can also be used to create a new, empty table using the schema of another. Just add a WHERE clause that 			causes the query to return no data:

		SELECT * INTO newtable
		FROM oldtable
		WHERE 1 = 0;



INSERT INTO  ____ SELECT :--


	The INSERT INTO SELECT statement copies data from one table and inserts it into another table.
	The INSERT INTO SELECT statement requires that the data types in source and target tables match.

	Note: The existing records in the target table are unaffected.



	Copy only some columns from one table into another table:

	INSERT INTO table2 (column1, column2, column3, ...)
	SELECT column1, column2, column3, ...
	FROM table1
	WHERE condition;





CASE WHEN THEN ELSE END:-- 

	The CASE expression goes through conditions and returns a value when the first condition is met (like an if-then-else statement). So, 		once a condition is true, it will stop reading and return the result. If no conditions are true, it returns the value in the ELSE 		clause.

	If there is no ELSE part and no conditions are true, it returns NULL.

	CASE
	    WHEN condition1 THEN result1
	    WHEN condition2 THEN result2
	    WHEN conditionN THEN resultN
	    ELSE result
	END; 





	SELECT OrderID, Quantity,
	CASE    
		WHEN Quantity > 30 THEN 'The quantity is greater than 30'
		WHEN Quantity = 30 THEN 'The quantity is 30'
		ELSE 'The quantity is under 30'
		END AS QuantityText
	FROM OrderDetails;

	result below;--

	Number of Records: 2155
	OrderID	Quantity	QuantityText
	10248	12	The quantity is under 30
	10248	10	The quantity is under 30
	10248	5	The quantity is under 30
	10249	9	The quantity is under 30
	10249	40	The quantity is greater than 30

	example :-
	SELECT CustomerName, City, Country
	FROM Customers
	ORDER BY
	(CASE
	    WHEN City IS NULL THEN Country
	    ELSE City
	END); 


SQL IFNULL(), ISNULL(),		 COALESCE(),	 and NVL() Functions:--
	|	|	  	     |	        	|	
  for MYSQL    sql,ms accesl   mysql,sql,oracle	     Oracle


	SELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0))
	FROM Products; 								// all works same way




STORED;- 
	A stored procedure is a prepared SQL code that you can save, so the code can be reused over and over again.
	So if you have an SQL query that you write over and over again, save it as a stored procedure, and then just call it to execute it.
	You can also pass parameters to a stored procedure, so that the stored procedure can act based on the parameter value(s) that is 	passed.

	creating procedure

	CREATE PROCEDURE procedure_name
	AS
	sql_statement
	GO; 

 	execusting procedure ;-
	EXC procedure_name

	


	Setting up multiple parameters is very easy. Just list each parameter and the data type separated by a comma as shown below.

		The following SQL statement creates a stored procedure that selects Customers from a particular City with a particular 			PostalCode from the "Customers" table:


	CREATE PROCEDURE SelectAllCustomers @City nvarchar(30), @PostalCode nvarchar(10)
	AS
	SELECT * FROM Customers WHERE City = @City AND PostalCode = @PostalCode
	GO;

	Execute the stored procedure above as follows:

	EXEC SelectAllCustomers @City = 'London', @PostalCode = 'WA1 1DP';



Comments
	Multi-line comments start with /* and end with */.
	Any text between /* and */ will be ignored.

		

	Single line comments start with --.
	Any text between -- and the end of the line will be ignored (will not be executed).







DATABASE CREATION :----

CREATION--
	The CREATE DATABASE statement is used to create a new SQL database.

	CREATE DATABASE databasename;

	Tip: Make sure you have admin privilege before creating any database. Once a database is created, you can check it in the list of 	databases with the following SQL command: SHOW DATABASES;



DROP--
	The DROP DATABASE statement is used to drop an existing SQL database.

	DROP DATABASE databasename;

	Note: Be careful before dropping a database. Deleting a database will result in loss of complete information stored in the database!


BACKUP -
      The BACKUP DATABASE statement is used in SQL Server to create a full back up of an existing SQL database.
	
	BACKUP DATABASE databasename
	TO DISK = 'filepath';

WITH DIFFERENTIAL 
  A differential back up only backs up the parts of the database that have changed since the last full database backup.
	
	BACKUP DATABASE databasename
	TO DISK = 'filepath'
	WITH DIFFERENTIAL;



CREATE TABLE :-

	 CREATE TABLE Persons (
	    PersonID int,
	    LastName varchar(255),
	    FirstName varchar(255),
	    Address varchar(255),
	    City varchar(255)
	);

	The PersonID column is of type int and will hold an integer.

	The LastName, FirstName, Address, and City columns are of type varchar and will hold characters, and the maximum length for these 	fields is 255 characters.
	


	CREATE TABLE new_table_name AS
	    SELECT column1, column2,...
	    FROM existing_table_name
	    WHERE ....;

	The following SQL creates a new table called "TestTables" (which is a copy of the "Customers" table): 
	
	CREATE TABLE TestTable AS
	SELECT customername, contactname
	FROM customers; 


DROP TABLE /TRUNCATE TABLE :-

	   The TRUNCATE TABLE statement is used to delete the data inside a table, but not the table itself.
	TRUNCATE TABLE table_name;

	The following SQL statement drops the existing table "Shippers":





ALTER TABLE:-


	The ALTER TABLE statement is used to add, delete, or modify columns in an existing table.
	The ALTER TABLE statement is also used to add and drop various constraints on an existing table.

ADD column 
	The following SQL adds an "Email" column to the "Customers" 		table:
		
	ALTER TABLE Customers
	ADD Email varchar(255);

DROP column ;
	 To delete a column in a table, use the following syntax (notice that some database systems don't allow deleting a column):
	ALTER TABLE table_name
	DROP COLUMN column_name; 

RENAME column 
	To rename a column in a table, use the following syntax:
	ALTER TABLE table_name
	RENAME COLUMN old_name to new_name; 

MODIFY/ALTER datatypes
     for mysql
	ALTER TABLE table_name
	MODIFY COLUMN column_name datatype; 


CONSTRAINTS:-
	Constraints can be specified when the table is created with the CREATE TABLE statement, or after the table is created with the ALTER TABLE statement.
	Syntax
	CREATE TABLE table_name (
	    column1 datatype constraint,
	    column2 datatype constraint,
	    column3 datatype constraint,
	    ....
	);

Constraints can be column level or table level. Column level constraints apply to a column, and table level constraints apply to the whole table.

The following constraints are commonly used in SQL:

    NOT NULL - Ensures that a column cannot have a NULL value
    UNIQUE - Ensures that all values in a column are different
    PRIMARY KEY - A combination of a NOT NULL and UNIQUE. Uniquely identifies each row in a table
    FOREIGN KEY - Prevents actions that would destroy links between tables
    CHECK - Ensures that the values in a column satisfies a specific condition
    DEFAULT - Sets a default value for a column if no value is specified
    CREATE INDEX - Used to create and retrieve data from the database very quickly




NOT NULL ;-
	Ensures that a column cannot have a NULL value	
	 ALTER TABLE Persons
	MODIFY COLUMN Age int NOT NULL; 


	CREATE TABLE Persons (
	    ID int NOT NULL,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255) NOT NULL,
	    Age int
	); 	

UNIQUE;-
	The UNIQUE constraint ensures that all values in a column are different.
	Both the UNIQUE and PRIMARY KEY constraints provide a guarantee for uniqueness for a column or set of columns.
	A PRIMARY KEY constraint automatically has a UNIQUE constraint.
	However, you can have many UNIQUE constraints per table, but only one PRIMARY KEY constraint per table.


	The following SQL creates a UNIQUE constraint on the "ID" column when the "Persons" table is created:

	SQL Server / Oracle / MS Access:-- 			// here we are adding unique constrints in each line

	CREATE TABLE Persons (
	    ID int NOT NULL UNIQUE,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255),
	    Age int
	);

	MySQL:							// here we are adding unique constrints in each line
	
	CREATE TABLE Persons (
	    ID int NOT NULL,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255),
	    Age int,
	    UNIQUE (ID)
	);

	To name a UNIQUE constraint, and to define a UNIQUE constraint on multiple columns, use the following SQL syntax:

	MySQL / SQL Server / Oracle / MS Access:

	CREATE TABLE Persons (
	    ID int NOT NULL,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255),
	    Age int,
	    CONSTRAINT UC_Person UNIQUE (ID,LastName)
	); 




adding the unique on already created table column

	ALTER TABLE Persons
	ADD UNIQUE (ID);

	To name a UNIQUE constraint, and to define a UNIQUE constraint on multiple columns, use the following SQL syntax:

	MySQL / SQL Server / Oracle / MS Access:
	ALTER TABLE Persons
	ADD CONSTRAINT UC_Person UNIQUE (ID,LastName); 				//here we have defined  name to constraints


droping unique contaraint from tale column 

	To drop a UNIQUE constraint, use the following SQL:

	MySQL:

	ALTER TABLE Persons
	DROP INDEX UC_Person;							//here we have deleted the constraints using name


	SQL Server / Oracle / MS Access:

	ALTER TABLE Persons
	DROP CONSTRAINT UC_Person; 


PRIMARY KEY :-

	The PRIMARY KEY constraint uniquely identifies each record in a table.
	Primary keys must contain UNIQUE values, and cannot contain NULL values.

	A table can have only ONE primary key; and in the table, this primary key can consist of single or multiple columns (fields).

	
	CREATE TABLE Persons (
	    ID int NOT NULL,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255),
	    Age int,
	    CONSTRAINT PK_Person PRIMARY KEY (ID,LastName)
	);

	Note: In the example above there is only ONE PRIMARY KEY (PK_Person). However, the VALUE of the primary key is made up of TWO COLUMNS (ID + LastName).


	for defining single column as primary key

	To create a PRIMARY KEY constraint on the "ID" column when the table is already created, use the following SQL:

	MySQL / SQL Server / Oracle / MS Access:

	ALTER TABLE Persons
	ADD PRIMARY KEY (ID);

	To allow naming of a PRIMARY KEY constraint, and for defining a PRIMARY KEY constraint on multiple columns, use the following SQL 

	MySQL / SQL Server / Oracle / MS Access:

	ALTER TABLE Persons
	ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName); 



	To drop a PRIMARY KEY constraint, use the following SQL:

	MySQL:
	ALTER TABLE Persons
	DROP PRIMARY KEY;

	SQL Server / Oracle / MS Access:
	ALTER TABLE Persons
	DROP CONSTRAINT PK_Person; 



FOREIGN KEY TABLE :-
	
	The FOREIGN KEY constraint is used to prevent actions that would destroy links between tables.
	A FOREIGN KEY is a field (or collection of fields) in one table, that refers to the PRIMARY KEY in another table.
	The table with the foreign key is called the child table, and the table with the primary key is called the referenced or parent table.


	CREATE TABLE Orders (
	    OrderID int NOT NULL,
	    OrderNumber int NOT NULL,
	    PersonID int,
	    PRIMARY KEY (OrderID),
	    CONSTRAINT FK_PersonOrder FOREIGN KEY (PersonID)
	    REFERENCES Persons(PersonID)
	); 
	

	To create a FOREIGN KEY constraint on the "PersonID" column when the "Orders" table is already created, use the following SQL:

	MySQL / SQL Server / Oracle / MS Access:
	ALTER TABLE Orders
	ADD FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);

	To allow naming of a FOREIGN KEY constraint, and for defining a FOREIGN KEY constraint on multiple columns, use the following SQL :

	MySQL / SQL Server / Oracle / MS Access:
	ALTER TABLE Orders
	ADD CONSTRAINT FK_PersonOrder
	FOREIGN KEY (PersonID) REFERENCES Persons(PersonID); 



 	droping the foreign  key :

	ALTER TABLE Orders
	DROP FOREIGN KEY FK_PersonOrder; 


CHECK ;
     check if age is greater than 18 then only allow that table  to create.
	 CREATE TABLE Persons (
	    ID int NOT NULL,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255),
	    Age int,
	    CHECK (Age>=18)
	); 

	for defining check on multiple column values>>

	CREATE TABLE Persons (
	    ID int NOT NULL,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255),
	    Age int,
	    City varchar(255),
	    CONSTRAINT CHK_Person CHECK (Age>=18 AND City='Sandnes')
	); 


	check or table if coulmn is already created:-

	ALTER TABLE Persons
	ADD CONSTRAINT CHK_PersonAge CHECK (Age>=18 AND City='Sandnes'); 
	

	droping check  with defined name ;

	ALTER TABLE Persons
	DROP CHECK CHK_PersonAge; 




DEFAULT :-
	The following SQL sets a DEFAULT value for the "City" column when the "Persons" table is created:

	My SQL / SQL Server / Oracle / MS Access:
	CREATE TABLE Persons (
	    ID int NOT NULL,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255),
	    Age int,
	    City varchar(255) DEFAULT 'Sandnes'
	);

	The DEFAULT constraint can also be used to insert system values, by using functions like GETDATE():
	CREATE TABLE Orders (
	    ID int NOT NULL,
	    OrderNumber int NOT NULL,
	    OrderDate date DEFAULT GETDATE()
	); 



	To create a DEFAULT constraint on the "City" column when the table is already created, use the following SQL:

	MySQL:

	ALTER TABLE Persons
	ALTER City SET DEFAULT 'Sandnes'; 


	To drop a DEFAULT constraint, use the following SQL:

	MySQL:
	ALTER TABLE Persons
	ALTER City DROP DEFAULT; 



INDEX:

	The CREATE INDEX statement is used to create indexes in tables.

	Indexes are used to retrieve data from the database more quickly than otherwise. The users cannot see the indexes, they are just used to speed up searches/queries.

	Note: Updating a table with indexes takes more time than updating a table without (because the indexes also need an update). So, only create indexes on columns that will be frequently searched against.

 indxes has much more in them but  i do not understsnad so i leave that 


AUTO INCREMENT :-

	CREATE TABLE Persons (
	    Personid int NOT NULL AUTO_INCREMENT,
	    LastName varchar(255) NOT NULL,
	    FirstName varchar(255),
	    Age int,
	    PRIMARY KEY (Personid)
	);

	MySQL uses the AUTO_INCREMENT keyword to perform an auto-increment feature.

	By default, the starting value for AUTO_INCREMENT is 1, and it will increment by 1 for each new record.

	To let the AUTO_INCREMENT sequence start with another value, use the following SQL statement:
	ALTER TABLE Persons AUTO_INCREMENT=100; 



	The MS SQL Server uses the IDENTITY keyword to perform an auto-increment feature. 
	Tip: To specify that the "Personid" column should start at value 10 and increment by 5, change it to IDENTITY(10,5).



Date :-
	MySQL comes with the following data types for storing a date or a date/time value in the database:

	    DATE - format YYYY-MM-DD
	    DATETIME - format: YYYY-MM-DD HH:MI:SS
	    TIMESTAMP - format: YYYY-MM-DD HH:MI:SS
	    YEAR - format YYYY or YY

	 SELECT * FROM Orders WHERE OrderDate='2008-11-11'

	If we use the same SELECT statement as above:
	SELECT * FROM Orders WHERE OrderDate='2008-11-11'

	we will get no result! This is because the query is looking only for dates with no time portion.

	Tip: To keep your queries simple and easy to maintain, do not use time-components in your dates, unless you have to!


VIEW :-
	In SQL, a view is a virtual table based on the result-set of an SQL statement.

	A view contains rows and columns, just like a real table. The fields in a view are fields from one or more real tables in the database.

	You can add SQL statements and functions to a view and present the data as if the data were coming from one single table.

	A view is created with the CREATE VIEW statement. 

	CREATE VIEW view_name AS
	SELECT column1, column2, ...
	FROM table_name
	WHERE condition; 

Note: A view always shows up-to-date data! The database engine recreates the view, every time a user queries it.              // main


example :
		 
		CREATE VIEW [Brazil Customers] AS
		SELECT CustomerName, ContactName
		FROM Customers
		WHERE Country = 'Brazil';

		We can query the view above as follows:
		Example
		
		SELECT * FROM [Brazil Customers]; 

UPDATING VIEW ;-

	A view can be updated with the CREATE OR REPLACE VIEW statement.

	The following SQL adds the "City" column to the "Brazil Customers" view:
	
	CREATE OR REPLACE VIEW [Brazil Customers] AS
	SELECT CustomerName, ContactName, City
	FROM Customers
	WHERE Country = 'Brazil'; 



DROPNIG VIEW:

	DROP VIEW [Brazil Customers]; 


MAIN HACKING TECHNIQUES : 
       	SQL INJECTION:-

		SQL injection is a code injection technique that might destroy your database.
		SQL injection is one of the most common web hacking techniques.					// MAIN  MAIN
		SQL injection is the placement of malicious code in SQL statements, via web page input.

  this is very big and you just need something at higher level...



DATA-TYPES in sql :-

	The data type of a column defines what value the column can hold: integer, character, money, date and time, binary, and so on.




Note: Data types might have different names in different database. And even if the name is the same, the size and other details may be different! Always check the documentation!

MySQL Data Types (Version 8.0)

In MySQL there are three main data types: string, numeric, and date and time.
String Data Types
Data type 	Description
CHAR(size) 	A FIXED length string (can contain letters, numbers, and special characters). The size parameter specifies the column length in characters - can be from 0 to 255. Default is 1
VARCHAR(size) 	A VARIABLE length string (can contain letters, numbers, and special characters). The size parameter specifies the maximum string length in characters - can be from 0 to 65535
BINARY(size) 	Equal to CHAR(), but stores binary byte strings. The size parameter specifies the column length in bytes. Default is 1
VARBINARY(size) 	Equal to VARCHAR(), but stores binary byte strings. The size parameter specifies the maximum column length in bytes.
TINYBLOB 	For BLOBs (Binary Large Objects). Max length: 255 bytes
TINYTEXT 	Holds a string with a maximum length of 255 characters
TEXT(size) 	Holds a string with a maximum length of 65,535 bytes
BLOB(size) 	For BLOBs (Binary Large Objects). Holds up to 65,535 bytes of data
MEDIUMTEXT 	Holds a string with a maximum length of 16,777,215 characters
MEDIUMBLOB 	For BLOBs (Binary Large Objects). Holds up to 16,777,215 bytes of data
LONGTEXT 	Holds a string with a maximum length of 4,294,967,295 characters
LONGBLOB 	For BLOBs (Binary Large Objects). Holds up to 4,294,967,295 bytes of data
ENUM(val1, val2, val3, ...) 	A string object that can have only one value, chosen from a list of possible values. You can list up to 65535 values in an ENUM list. If a value is inserted that is not in the list, a blank value will be inserted. The values are sorted in the order you enter them
SET(val1, val2, val3, ...) 	A string object that can have 0 or more values, chosen from a list of possible values. You can list up to 64 values in a SET list




	Numeric Data Types
	Data type 	Description
	BIT(size) 	A bit-value type. The number of bits per value is specified in size. The size parameter can hold a value from 1 to 64. 				The default value for size is 1.
	TINYINT(size) 	A very small integer. Signed range is from -128 to 127. Unsigned range is from 0 to 255. The size parameter specifies 				the maximum display width (which is 255)
	BOOL 	Zero is considered as false, nonzero values are considered as true.
	BOOLEAN 	Equal to BOOL
	SMALLINT(size) 	A small integer. Signed range is from -32768 to 32767. Unsigned range is from 0 to 65535. The size parameter specifies 				the maximum display width (which is 255)
	MEDIUMINT(size) 	A medium integer. Signed range is from -8388608 to 8388607. Unsigned range is from 0 to 16777215. The size 					parameter specifies the maximum display width (which is 255)
	INT(size) 	A medium integer. Signed range is from -2147483648 to 2147483647. Unsigned range is from 0 to 4294967295. The size 				parameter specifies the maximum display width (which is 255)
	INTEGER(size) 	Equal to INT(size)
	BIGINT(size) 	A large integer. Signed range is from -9223372036854775808 to 9223372036854775807. Unsigned range is from 0 to 				18446744073709551615. The size parameter specifies the maximum display width (which is 255)
	FLOAT(size, d) 	A floating point number. The total number of digits is specified in size. The number of digits after the decimal point 				is specified in the d parameter. This syntax is deprecated in MySQL 8.0.17, and it will be removed in future MySQL 				versions
	FLOAT(p) 	A floating point number. MySQL uses the p value to determine whether to use FLOAT or DOUBLE for the resulting data 				type. If p is from 0 to 24, the data type becomes FLOAT(). If p is from 25 to 53, the data type becomes DOUBLE()
	DOUBLE(size, d) 	A normal-size floating point number. The total number of digits is specified in size. The number of digits 				after the decimal point is specified in the d parameter
	DOUBLE PRECISION(size, d) 	 
	DECIMAL(size, d) 	An exact fixed-point number. The total number of digits is specified in size. The number of digits after the 					decimal point is specified in the d parameter. The maximum number for size is 65. The maximum number for d is 					30. The default value for size is 10. The default value for d is 0.
	DEC(size, d) 	Equal to DECIMAL(size,d)

	Note: All the numeric data types may have an extra option: UNSIGNED or ZEROFILL. If you add the UNSIGNED option, MySQL disallows negative values for the column. If you add the ZEROFILL option, MySQL automatically also adds the UNSIGNED attribute to the column.
Date and Time Data Types




	DATE 	A date. Format: YYYY-MM-DD. The supported range is from '1000-01-01' to '9999-12-31'
	DATETIME(fsp) 	A date and time combination. Format: YYYY-MM-DD hh:mm:ss. The supported range is from '1000-01-01 00:00:00' to 				'9999-12-31 23:59:59'. Adding DEFAULT and ON UPDATE in the column definition to get automatic initialization and 				updating to the current date and time
	TIMESTAMP(fsp) 	A timestamp. TIMESTAMP values are stored as the number of seconds since the Unix epoch ('1970-01-01 00:00:00' UTC). 				Format: YYYY-MM-DD hh:mm:ss. The supported range is from '1970-01-01 00:00:01' UTC to '2038-01-09 03:14:07' UTC. 				Automatic initialization and updating to the current date and time can be specified using DEFAULT CURRENT_TIMESTAMP 				and ON UPDATE CURRENT_TIMESTAMP in the column definition
	TIME(fsp) 	A time. Format: hh:mm:ss. The supported range is from '-838:59:59' to '838:59:59'
	YEAR 	A year in four-digit format. Values allowed in four-digit format: 1901 to 2155, and 0000.
	MySQL 8.0 does not support year in two-digit format.



SQL Server Data Types:

String Data Types
Data type 	Description 	Max size 	Storage
char(n) 	Fixed width character string 	8,000 characters 	Defined width
varchar(n) 	Variable width character string 	8,000 characters 	2 bytes + number of chars
varchar(max) 	Variable width character string 	1,073,741,824 characters 	2 bytes + number of chars
text 	Variable width character string 	2GB of text data 	4 bytes + number of chars
nchar 	Fixed width Unicode string 	4,000 characters 	Defined width x 2
nvarchar 	Variable width Unicode string 	4,000 characters 	 
nvarchar(max) 	Variable width Unicode string 	536,870,912 characters 	 
ntext 	Variable width Unicode string 	2GB of text data 	 
binary(n) 	Fixed width binary string 	8,000 bytes 	 
varbinary 	Variable width binary string 	8,000 bytes 	 
varbinary(max) 	Variable width binary string 	2GB 	 
image 	Variable width binary string 	2GB 	

 
Numeric Data Types
Data type 	Description 	Storage
bit 	Integer that can be 0, 1, or NULL 	 
tinyint 	Allows whole numbers from 0 to 255 	1 byte
smallint 	Allows whole numbers between -32,768 and 32,767 	2 bytes
int 	Allows whole numbers between -2,147,483,648 and 2,147,483,647 	4 bytes
bigint 	Allows whole numbers between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807 	8 bytes
decimal(p,s) 	Fixed precision and scale numbers.

Allows numbers from -10^38 +1 to 10^38 –1.

The p parameter indicates the maximum total number of digits that can be stored (both to the left and to the right of the decimal point). p must be a value from 1 to 38. Default is 18.

The s parameter indicates the maximum number of digits stored to the right of the decimal point. s must be a value from 0 to p. Default value is 0
	5-17 bytes
numeric(p,s) 	Fixed precision and scale numbers.

Allows numbers from -10^38 +1 to 10^38 –1.

The p parameter indicates the maximum total number of digits that can be stored (both to the left and to the right of the decimal point). p must be a value from 1 to 38. Default is 18.

The s parameter indicates the maximum number of digits stored to the right of the decimal point. s must be a value from 0 to p. Default value is 0
	5-17 bytes
smallmoney 	Monetary data from -214,748.3648 to 214,748.3647 	4 bytes
money 	Monetary data from -922,337,203,685,477.5808 to 922,337,203,685,477.5807 	8 bytes
float(n) 	Floating precision number data from -1.79E + 308 to 1.79E + 308.

The n parameter indicates whether the field should hold 4 or 8 bytes. float(24) holds a 4-byte field and float(53) holds an 8-byte field. Default value of n is 53.
	4 or 8 bytes
real 	Floating precision number data from -3.40E + 38 to 3.40E + 38 	4 bytes
Date and Time Data Types
Data type 	Description 	Storage
datetime 	From January 1, 1753 to December 31, 9999 with an accuracy of 3.33 milliseconds 	8 bytes
datetime2 	From January 1, 0001 to December 31, 9999 with an accuracy of 100 nanoseconds 	6-8 bytes
smalldatetime 	From January 1, 1900 to June 6, 2079 with an accuracy of 1 minute 	4 bytes
date 	Store a date only. From January 1, 0001 to December 31, 9999 	3 bytes
time 	Store a time only to an accuracy of 100 nanoseconds 	3-5 bytes
datetimeoffset 	The same as datetime2 with the addition of a time zone offset 	8-10 bytes
timestamp 	Stores a unique number that gets updated every time a row gets created or modified. The timestamp value is based upon an internal clock and does not correspond to real time. Each table may have only one timestamp variable 	 
Other Data Types
Data type 	Description
sql_variant 	Stores up to 8,000 bytes of data of various data types, except text, ntext, and timestamp
uniqueidentifier 	Stores a globally unique identifier (GUID)
xml 	Stores XML formatted data. Maximum 2GB
cursor 	Stores a reference to a cursor used for database operations
table 	Stores a result-set for later processing




















		















Question and there answer>>>

1>>
get the first name ,last name  and gender from the table whose gender value is equal to "M"

SELECT first_name, last_name, gender FROM patients
where gender="M";

2>>
get all patience's first name ,last name  from the table who doesnot have allergies.(Null).

SELECT first_name,last_name FROM patients
where allergies is null ;                                            // for checking the value is null 


3>>
Show first name of patients that start with the letter 'C'

SELECT first_name FROM patients
where first_name like 'c%';    					 // here like is giving the text checking mechanism		


4>> 
it will  give only count as DistinctCountries with value (number)    from (we will select distinct country from customers).

SELECT Count(*) AS DistinctCountries
FROM (SELECT DISTINCT Country FROM Customers);













